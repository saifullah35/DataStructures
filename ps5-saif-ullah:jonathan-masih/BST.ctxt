#BlueJ class context
comment0.target=BST
comment0.text=\n\ A\ binary\ search\ tree\ (BST)\ data\ structure\ for\ storing\ floating\ point\n\ values.\ The\ tree\ has\ the\ property\ that\ for\ every\ node\ n,\ all\ values\n\ in\ n's\ left\ subtree\ are\ less\ than\ or\ equal\ to\ n's\ data\ value\ and\n\ all\ values\ in\ n's\ right\ subtree\ are\ larger.\n\ \n\ Starter\ code\ by\ Siena\ College\ Faculty,\ modified\ by\ Pauline\ White\n\ for\ CSIS\ 210,\ Spring\ 2018\n\n\ @author\ (Saif\ Ullah\ and\ Jonathan\ Masih)\n\ @version\ (May\ 10,\ 2021)\n
comment1.params=
comment1.target=BST()
comment1.text=\n\ Constructs\ an\ empty\ binary\ search\ tree\ (BST).\n
comment10.params=value
comment10.target=void\ addIterative(java.lang.Comparable)
comment10.text=\n\ Adds\ the\ value\ to\ the\ BST.\ Uses\ an\ iterative\n\ algorithm.\n\ \n\ @param\ value\ The\ value\ to\ insert\ into\ the\ BST.\n
comment11.params=
comment11.target=java.lang.Comparable\ getLargestIterative()
comment11.text=\n\ Returns\ the\ largest\ value\ in\ the\ BST.\ Assumes\ the\ BST\ \n\ contains\ at\ least\ one\ value.\ \n\ \n\ @return\ the\ largest\ value\ in\ the\ (non-empty)\ BST.\n
comment12.params=n
comment12.target=java.lang.Comparable\ getLargestIterative(BST.Node)
comment12.text=\n\ Returns\ the\ largest\ value\ in\ the\ BST\ (or\ subtree)\ \n\ whose\ root\ is\ n.\ Uses\ an\ iterative\ algorithm.\n\ \n\ Precondition\:\ \ The\ BST\ contains\ at\ least\ one\ value.\ \ \n\ @param\ n\ The\ root\ of\ BST\ being\ searched.\ \n\ @return\ The\ largest\ value\ in\ the\ BST\ (or\ subtree)\ whose\n\ root\ is\ n.\n
comment13.params=
comment13.target=void\ removeLargestIterative()
comment13.text=\n\ Removes\ the\ largest\ value\ in\ the\ BST.\ \ Uses\ an\n\ iterative\ algorithm.\ \n
comment14.params=n
comment14.target=void\ removeLargestIterative(BST.Node)
comment14.text=\n\ Removes\ the\ largest\ value\ in\ the\ BST\ whose\ root\ is\ n\ using\n\ an\ iterative\ algorithm.\n\ \n\ Precondition\:\ \ n\ is\ not\ null\ and\ n\ itself\ does\ not\ contain\ the\ \n\ largest\ value\ in\ its\ subtree.\ In\ other\ words,\ n.right\ \!\=\ null.\ \n\ \n\ @param\ n\ The\ root\ of\ the\ BST\ (or\ subtree)\ whose\ largest\ value\ is\ \n\ removed.\n
comment15.params=value
comment15.target=void\ remove(java.lang.Comparable)
comment15.text=\n\ Removes\ one\ copy\ of\ the\ value\ from\ the\ tree.\ If\ value\ is\n\ not\ in\ tree,\ it\ does\ nothing.\n\ \n\ @param\ value\ the\ value\ being\ removed\n
comment16.params=root\ array
comment16.target=void\ bstIntoArraylist(BST.Node,\ java.util.ArrayList)
comment16.text=\n\ Inserts\ all\ the\ elements\ of\ the\ BinarySearchTree\ into\ array\ list.\n\ @param\ Root\ of\ the\ BinarySearchTree\ \n\ @param\ ArrayList\ to\ store\ the\ values\ of\ BinarySearchTree\ \n
comment17.params=obj
comment17.target=boolean\ equals(java.lang.Object)
comment17.text=\n\ Checks\ if\ two\ trees\ contains\ the\ same\ values\n\ \n\ @param\ BinarySearchTree\ \n
comment18.params=
comment18.target=BST.Node\ getRoot()
comment19.params=root1\ root2
comment19.target=boolean\ shapeEquals(BST.Node,\ BST.Node)
comment2.params=value
comment2.target=void\ add(java.lang.Comparable)
comment2.text=\n\ Adds\ the\ value\ to\ the\ tree\ maintianing\ the\ BST\n\ property\ that\ for\ every\ tree\ node\ n,\ all\ values\ in\ n's\ left\n\ subtree\ are\ less\ than\ or\ equal\ to\ n's\ data\ value\ and\ all\ values\n\ in\ n's\ right\ subtree\ are\ larger.\n\ \n\ @param\ value\ The\ value\ to\ be\ added\ to\ the\ BST.\n
comment20.params=
comment20.target=java.lang.String\ toString()
comment21.params=n
comment21.target=java.lang.String\ inOrder(BST.Node)
comment3.params=value\ n
comment3.target=void\ recursiveAdd(java.lang.Comparable,\ BST.Node)
comment3.text=\n\ Recursive\ method\ to\ add\ a\ value\ to\ a\ BST\ with\ root\ n.\n\ \n\ Precondition\:\ n\ is\ not\ null\n\ @param\ value\ The\ value\ to\ be\ added\ to\ the\ BST.\n\ @param\ n\ The\ root\ of\ the\ BST.\n
comment4.params=
comment4.target=void\ printAll()
comment4.text=\n\ Prints\ the\ values\ in\ the\ BST.\n
comment5.params=n
comment5.target=void\ recursivePrintAll(BST.Node)
comment5.text=\n\ Recursively\ prints\ the\ values\ in\ the\ BST\ whose\ root\ is\ n.\n\ \n\ @param\ n\ The\ root\ of\ the\ tree\ (or\ subtree).\n
comment6.params=
comment6.target=int\ numLeaves()
comment6.text=\n\ Returns\ the\ number\ of\ leaves\ in\ the\ BST.\n\ \n\ @return\ The\ number\ of\ leaves\ in\ the\ BST.\n
comment7.params=n
comment7.target=int\ numLeaves(BST.Node)
comment7.text=\n\ Returns\ the\ number\ of\ leaves\ in\ the\ BST\ whose\n\ root\ is\ node\ n.\n\ \n\ @param\ The\ root\ of\ the\ BST\ (or\ subtree).\n\ @return\ The\ number\ of\ leaves\ in\ the\ BST\ whose\n\ root\ is\ node\ n.\n
comment8.params=value
comment8.target=boolean\ contains(java.lang.Comparable)
comment8.text=\n\ \ Returns\ true\ if\ the\ value\ exists\ in\ the\ BST\ and\ false\n\ \ otherwise.\ \ Finds\ the\ value\ recursively.\n\ \ Call\ the\ recursive\ method\ appropriately.\n\n\ @param\ value\ The\ value\ to\ search\ for\ in\ the\ BST.\n\ @return\ true\ If\ the\ value\ is\ found\ and\ false\ otherwise.\n
comment9.params=n\ value
comment9.target=boolean\ contains(BST.Node,\ java.lang.Comparable)
comment9.text=\n\ \ Returns\ true\ if\ the\ value\ exists\ in\ the\ BST\ whose\ root\n\ \ is\ n\ and\ false\ otherwise.\ \ Finds\ the\ value\ recursively.\n\n\ @param\ value\ The\ value\ to\ search\ for\ in\ the\ BST\ (or\ subtree)\n\ whose\ root\ is\ n.\n\ @return\ true\ If\ the\ value\ is\ found\ and\ false\ otherwise.\n
numComments=22
